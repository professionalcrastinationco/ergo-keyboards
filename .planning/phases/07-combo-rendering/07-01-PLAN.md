---
phase: 07-combo-rendering
plan: 01
type: execute
---

<objective>
Render layer-level combos with visual badges: floating badges between adjacent keys, color-matched badges on non-adjacent keys.

Purpose: Visual indication of combo pairs with intuitive positioning based on key adjacency.
Output: Combos render correctly with appropriate badge styles, updating on layer switch.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/COMBO-VISUALIZATION-PLAN.md

**Prior decisions affecting this phase:**
- v1.1: Adjacent badge at midpoint between keys
- v1.1: Non-adjacent badge at bottom center of key
- v1.1: Multi-combo per key allowed, badges side by side
- Phase 6: COMBO_COLORS, getKeyPosition, areKeysAdjacent already implemented
- Phase 6: layer.combos = [{keys: [{side, index}, ...], output}]

@app.js
@styles.css
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CSS for combo badges</name>
  <files>styles.css</files>
  <action>
Add combo badge styles after the existing `.chord-notation` styles (around line 595):

1. Floating badge for adjacent combos:
```css
/* Layer-level combo badges (v1.1) */
.combo-floating-badge {
  position: absolute;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #888;
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 9px;
  font-weight: 600;
  color: #333;
  z-index: 20;
  pointer-events: none;
  white-space: nowrap;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
```

2. Non-adjacent combo badge (positioned bottom center of key):
```css
.key .combo-color-badge {
  position: absolute;
  bottom: 2px;
  padding: 1px 5px;
  border-radius: 6px;
  font-size: 7px;
  font-weight: 600;
  color: white;
  text-shadow: 0 1px 1px rgba(0,0,0,0.4);
  white-space: nowrap;
}
```

3. Container for multiple badges on same key:
```css
.key .combo-badges-container {
  position: absolute;
  bottom: 2px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 2px;
}
```
  </action>
  <verify>Inspect styles.css for new combo-floating-badge, combo-color-badge, and combo-badges-container classes</verify>
  <done>CSS classes added for floating and color badges</done>
</task>

<task type="auto">
  <name>Task 2: Create renderCombos() function</name>
  <files>app.js</files>
  <action>
Add after the renderLayout() function:

```javascript
/**
 * Render combo badges for the current layer
 * Adjacent combos: floating badge between keys
 * Non-adjacent combos: colored badge on each key
 * @param {string} layer - Layer name
 */
function renderCombos(layer) {
    // Clear existing combo badges
    document.querySelectorAll('.combo-floating-badge').forEach(el => el.remove());
    document.querySelectorAll('.combo-badges-container').forEach(el => el.remove());

    const layerData = layouts[layer];
    if (!layerData.combos || layerData.combos.length === 0) return;

    // Track non-adjacent badges per key for side-by-side display
    const keyBadges = {}; // { "left-5": [{output, color}, ...] }

    layerData.combos.forEach((combo, comboIndex) => {
        const [key1, key2] = combo.keys;
        const isAdjacent = areKeysAdjacent(key1, key2);

        if (isAdjacent) {
            renderAdjacentComboBadge(combo, key1, key2, layer);
        } else {
            // Assign color from palette
            const color = COMBO_COLORS[comboIndex % COMBO_COLORS.length];

            // Track badges for each key
            const key1Id = `${key1.side}-${key1.index}`;
            const key2Id = `${key2.side}-${key2.index}`;

            if (!keyBadges[key1Id]) keyBadges[key1Id] = [];
            if (!keyBadges[key2Id]) keyBadges[key2Id] = [];

            keyBadges[key1Id].push({ output: combo.output, color });
            keyBadges[key2Id].push({ output: combo.output, color });
        }
    });

    // Render non-adjacent badges (grouped per key)
    for (const [keyId, badges] of Object.entries(keyBadges)) {
        const [side, indexStr] = keyId.split('-');
        const index = parseInt(indexStr);
        renderNonAdjacentComboBadges(side, index, badges, layer);
    }
}
```
  </action>
  <verify>Console: typeof renderCombos === 'function'</verify>
  <done>renderCombos() function created with adjacent/non-adjacent routing</done>
</task>

<task type="auto">
  <name>Task 3: Add renderAdjacentComboBadge() helper</name>
  <files>app.js</files>
  <action>
Add after renderCombos():

```javascript
/**
 * Render a floating badge between two adjacent keys
 * @param {Object} combo - {keys, output}
 * @param {Object} key1 - {side, index}
 * @param {Object} key2 - {side, index}
 * @param {string} layer - Layer name
 */
function renderAdjacentComboBadge(combo, key1, key2, layer) {
    const el1 = getKeyElement(layer, key1.side, key1.index);
    const el2 = getKeyElement(layer, key2.side, key2.index);

    if (!el1 || !el2) return;

    const container = document.getElementById('keyboard-container');
    const containerRect = container.getBoundingClientRect();
    const rect1 = el1.getBoundingClientRect();
    const rect2 = el2.getBoundingClientRect();

    // Calculate midpoint between key centers
    const midX = (rect1.left + rect1.width/2 + rect2.left + rect2.width/2) / 2;
    const midY = (rect1.top + rect1.height/2 + rect2.top + rect2.height/2) / 2;

    // Create floating badge
    const badge = document.createElement('div');
    badge.className = 'combo-floating-badge';
    badge.textContent = combo.output;

    // Position relative to container
    badge.style.left = `${midX - containerRect.left}px`;
    badge.style.top = `${midY - containerRect.top}px`;
    badge.style.transform = 'translate(-50%, -50%)';

    container.appendChild(badge);
}
```
  </action>
  <verify>Console: typeof renderAdjacentComboBadge === 'function'</verify>
  <done>renderAdjacentComboBadge() creates floating badge at key midpoint</done>
</task>

<task type="auto">
  <name>Task 4: Add renderNonAdjacentComboBadges() helper</name>
  <files>app.js</files>
  <action>
Add after renderAdjacentComboBadge():

```javascript
/**
 * Render colored badges on a key for non-adjacent combos
 * @param {string} side - 'left' or 'right'
 * @param {number} index - Key index
 * @param {Array} badges - [{output, color}, ...]
 * @param {string} layer - Layer name
 */
function renderNonAdjacentComboBadges(side, index, badges, layer) {
    const keyEl = getKeyElement(layer, side, index);
    if (!keyEl) return;

    // Create container for badges (side by side)
    const container = document.createElement('div');
    container.className = 'combo-badges-container';

    badges.forEach(({ output, color }) => {
        const badge = document.createElement('div');
        badge.className = 'combo-color-badge';
        badge.textContent = output;
        badge.style.backgroundColor = color;
        container.appendChild(badge);
    });

    keyEl.appendChild(container);
}
```
  </action>
  <verify>Console: typeof renderNonAdjacentComboBadges === 'function'</verify>
  <done>renderNonAdjacentComboBadges() adds colored badges to key element</done>
</task>

<task type="auto">
  <name>Task 5: Call renderCombos() after renderLayout()</name>
  <files>app.js</files>
  <action>
Find the renderLayout() function and add renderCombos() call at the end, after the requestAnimationFrame for zoom:

```javascript
    // Re-apply zoom after layout renders
    requestAnimationFrame(() => {
        setZoom(currentZoom);
        renderCombos(layer); // Add this line
    });
```

Also export renderCombos in window.keyboardEditor.
  </action>
  <verify>Switch layers in browser - combos should render (test by adding a combo via console: window.keyboardEditor.layouts().base.combos.push({keys: [{side:'left',index:7}, {side:'left',index:8}], output:'TEST'}); then switch layers)</verify>
  <done>renderCombos() called after layout render, exported to API</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] CSS classes exist: .combo-floating-badge, .combo-color-badge, .combo-badges-container
- [ ] renderCombos() function exists and is exported
- [ ] renderAdjacentComboBadge() positions badge at midpoint
- [ ] renderNonAdjacentComboBadges() adds colored badges to keys
- [ ] Layer switch triggers combo re-render
- [ ] Test adjacent combo: add combo to console, verify floating badge
- [ ] Test non-adjacent combo: add cross-side combo, verify colored badges
- [ ] No JavaScript errors in console
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Combos render visually correct
- Layer switching clears and re-renders combos
- Existing functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/07-combo-rendering/07-01-SUMMARY.md`:

# Phase 7 Plan 1: Combo Rendering Summary

**[One-line summary of what was accomplished]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `styles.css` - Description of changes
- `app.js` - Description of changes

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Phase complete, ready for Phase 8: Combo Editing
</output>
